### 1. 索引原理
```
# 优点：提高数据检索效率；降低排序成本，降低cpu消耗
# 缺点：占据空间；降低更新表的效率

# 索引      innoDB  Myisam  Memory
# B+tree      1       1       1
# Hash        0       0       1

# Btree（n个key,n+1个pointer）向上裂变

# B+tree（n个key,n+1个pointer）向上裂变
# 非叶子节点主要起到索引作用
# 所有数据出现在叶子节点
# 叶子节点形成一个单向链表
# Mysql的B+tree相邻叶子节点形成双向链表

# Hash
# 只能用于对比(=,in),不支持范围查询(between,>,<...)、
# 无法利用索引完成排序操作
# 查询效率高，无hash碰撞下只需要一场检索，效率高于B+tree

# InnoDB的两种索引
# 聚集索引(Clustered Index)：数据与索引一起，索引结构的叶子节点保存了行数据   必须有且唯一
# 二级索引(Secondary Index)：数据与索引分开，索引结构的叶子节点关联对应主键   可以存在多个

# 聚集索引：
# 主键>唯一索引>生成rowid

# 查找
# 聚集索引的节点按照主键排，叶子节点存放行数据
# 二级索引的节点按照字段排，叶子节点存放主键值
# 回表查询：在二级索引查到主键后，进入到聚集索引中查找行数据
```

### 2. 基本操作
```
# 创建索引
create [unique|fulltext] index idx_name on tb_name(col_name1,col_name2,);

# 查看索引
show index from tb_name;

# 删除索引
drop index idx_name on tb_name;

# 修改索引
alter table...

# 例子
select database();

select * from t1;

show index from t1;

create index idx_id on t1(id);

create unique index idx_name on t1(name);
```

### 3. 性能分析
```
# 查看当前数据库的命令使用数量
show global status like 'com_______';  # 模糊匹配，七个下划线，select,insert,update...


# 慢查询日志记录所有执行时间超过long_query_time默认10秒的语句
# 查看慢查询状态
show variables like '%slow_query_log%';

# 开启慢查询
set global slow_query_log = 1;

# 设置慢查询时间
set global long_query_time = 2;


# profile:查看每一条sql语句的执行时间
# 查看是否支持profile
select @@have_profiling;

# 查看profile是否开启
select @@profiling;

# 开启profile:
set profiling = 1;

# 查看每一条sql语句的执行情况
show profiles;

# 查看指定query_id的sql语句的各阶段的执行情况
show profile for query query_id;

# 查看指定query_id的sql语句的cpu使用情况
show profile cpu for query query_id;


# explain执行计划
explain/desc select col_name from tb_name where 条件;

# explain中各个字段的含义：
# id：查询序列号，大的优先，相同时由上往下
# select_type：查询类型
# type：连接类型，null>system>const>eq_ref>ref>range>index>all
# possible_key：可能用到的索引
# key：实际用到的索引
# key_len：索引字节数
# rows：总查询的行数
# filtered：返回结果的行数占读取行数的百分比
# extra: 使用的查询类型 use where,use index;Null
```

### 4，高级应用
```
# 联合索引
# 最左前缀法则：联合索引的第一个字段必须存在，否则后面的字段索引失效
# 通过explain的key_len计算各字段的索引长度，以此分辨那个字段的索引失效

# 范围查询：使用>、<后面的字段索引失效
# 尽量使用>=、<=来替代

# 索引失效：
# 索引列上进行运算操作
# 字符串不加引号
# 头部模糊匹配
# or其中一个条件无索引
# 使用索引比全表扫描慢

# sql提示
# use index： 指定使用索引
select * from tb_name use index(idx_name_pro) where profession = '软件工程';

# ignore index:  忽略索引
select * from tb_name ignore index(idx_name_pro) where profession = '软件工程';

# force index:  强迫使用索引
select * from tb_name force index(idx_name_pro) where profession = '软件工程';

# 覆盖索引
# id为主键，name为二级索引
# 此时只需要在二级索引中查询就能找到所需的id和name并不需要回表查询
select id,name from tb_name where name = "arm";

# 使用联合索引同理
# id为主键，name,pro,ads为联合索引
select id,name,pro,ads from tb_name where name = "arm" and pro = "软件工程" and ads = 0;


# 前缀索引
# 当需要查询文本文件时，文本太长，就算使用索引也是很耗费时间，因此抽取文本的一部分来建立索引最佳

# 查看有多少条数据
select count(*) from tb_user;

# 查看有多少条不为空的数据
select count(col_name) from tb_user;

# 查看有所少条不同的数据
select count(distinct col_name) from tb_user;

# 表示不同数比上总数
select count(distinct col_name)/count(*) from tb_user;

# 表示截取字符后不同数比上总数
select count(distinct substring(col_name,1,10))/count(*) from tb_user;
不断减少截取长度以获取效率，同时精准度也会下降，需要按照具体事务来选择

# 截取长度创立索引
create index idx_col_name_n ob tb_name(col_name(length));
length为所截取的前缀长度，cub_part = length
```
