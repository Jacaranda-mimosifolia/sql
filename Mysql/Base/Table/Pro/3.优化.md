### 1. 优化
```
# 插入优化
# insert 主键顺序插入，批量插入，手动控制事务
# load 插入大量数据

# 主键优化
# 页分裂，乱序插入可能会导致页分裂
# 页合并，删除数据可能会导致页合并
# 1.尽量降低主键的长度，降低二级索引的存储量
# 2.尽量顺序插入，使用auto_increment自增主键
# 3.尽量避免使用自然主键和uuid主键，如身份证号
# 4.尽量避免主键修改

# 排序优化
# using filesort:全表扫描，会在缓冲区sort buffer排序后返回，效率低
# using index:索引顺序扫描，在创建索引时已经经过b+tree排序，效率高
# 1.多字段排序时，使用覆盖索引，遵循最左前缀法则
# 2.多字段排序，一个升序一个降序，注意在创建联合索引时使用(asc/desc)
# 3.若要使用filesort，注意sort_buffer_size(默认256k)

# sort_buffer_size
select @@sort_buffer_size;  # 262144
set sort_buffer_size=262144*10;  # 2621440
```

```
# order by
# 创建符合需求排序的联合索引，获取该排序
# create index id_user_age_phone_ad on tb_user(age asc, phone desc)
# explain select id,age,phone from tb_user order by age asc,phone desc;

# group by
# 创建联合索引，遵循最左前缀法则
# create index idx_user_pro_age_sta on tb_user(profession,age,status);
# explain select profession,count(*) from tb_user where profession='软件工程' group by age;

# limit
# 想要查询900000,900010的数据，先是使用分页查询获得该数据所对应的主键值，再使用联合查询，走的是聚合索引
# select s.* from tb_sku s,(select id from tb_sku order by id limit 900000,10) a where s.id = a.id;

# update
# 并行事务更新数据时，建议根据索引更新，则为行锁，否则为表锁
```