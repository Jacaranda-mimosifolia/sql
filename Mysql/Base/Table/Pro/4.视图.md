### 1. 视图操作
```
# 视图是一种虚拟存在的表。视图中的数据并不在数据库中实际存在
# 而是来自自定义视图查询中使用的表，并且是在使用视图时动态生成的。
# 因此创建视图的重点在于后面的select语句
# 特点：
# 1.简单，将展示经常需要查询的定义成视图，方便查询
# 2.安全，数据真正存储在数据库中，用户只能查询和修改视图中的数据，屏蔽部分字段
# 3.数据独立，当字段名改变时，视图只需要设置别名，而不过多的影响后面的事务
# 视图的更新：必须使视图与基表中的数据一对一，否则不能更新
# 使用视图会降低一定的效率，而使用物化视图，本地物理存储，能够提升性能

# 创建
create [or replace] view view_name as select * from table_name;

# 查询
show create view view_name;
select * from view_name;

# 修改 or replace 表示替换视图
create or replace view view_name as select * from table_name;
alter view view_name as select * from table_name;

# 删除
drop view [if exists] view_name;
```

```
# [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}]
# UNDEFINED算法是默认算法，根据查询的复杂程度和其他因素自动选择执行方式，但缺乏直接控制执行方式的能力。
# MERGE算法将视图查询与外部查询合并成一个查询，适用于简单的视图查询，可以提高性能。
# TEMPTABLE算法将视图的结果存储在临时表中，然后再执行外部查询，适用于复杂的视图查询，但可能会导致性能较低和额外的资源开销。

## 视图的检查选项 [with [casaded|local] check option], 默认casaded
# 在单层视图中都能遵循视图插入的条件
# 在多层继承视图中：
# casaded       子视图出现casaded，需要检查子视图和父视图的条件
# local         子视图出现local，只需要满足当前视图的条件

# 不加检查选项，数据是直接插入到数据表中的，视图不显示不符合的条件的数据
create view exl_v_1 as select id, age from excel_table where age<=30;
insert into exl_v_1 values(6,35);  # 插入成功

# casaded检查选项，数据需要满足子视图和父视图的条件，否则插入失败
create view exl_v_2 as select id, age from exl_v_1 where age>=20 with cascaded check option ;
insert into exl_v_2 values(7,32);  # 插入失败

# local检查选项，数据只需要满足当前视图的条件
create view exl_v_3 as select id, age from exl_v_1 where age>=20 with local check option ;
insert into exl_v_3 values(7,32);  # 插入成功
```
