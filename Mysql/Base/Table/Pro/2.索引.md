### 1. 索引原理
```
# 优点：提高数据检索效率；降低排序成本，降低cpu消耗
# 缺点：占据空间；降低更新表的效率；b+tree节点的分裂与合并

# 索引      InnoDB  Myisam  Memory
# B+tree      1       1       1
# Hash        0       0       1

# InnoDB的B+tree（n个key,n+1个pointer）向上裂变
# 非叶子节点只存 Key + 指针，主要起到索引作用
# 所有数据都存储在叶子节点
# 叶子节点形成一个双向链表

# Hash
# 只能用于对比(=,in),不支持范围查询(between,>,<...)、
# 无法利用索引完成排序操作
# 查询效率高，无hash碰撞下只需要一场检索，效率高于B+tree
```

### 2. InnoDB B+tree
```
# InnoDB的两种索引:
# 聚集索引(Clustered Index)/主键索引：
数据与索引一起，索引结构的叶子节点保存了行数据
每张表都必须有且唯一一个聚集索引

                 (Root)
               [ 10 | 20 ]
               /    |     \
              /     |      \
         [1|5|9]  [10|15]  [20|25|30]     <- 内节点：key + child pointer
    
           |         |           |
           v         v           v
        (Leaf)     (Leaf)       (Leaf)
    +-----------+ +-----------+ +----------------+
    | pk=1  row | | pk=10 row | | pk=20  row     |  <- 叶子节点：保存(主键值pk, 行数据)
    | pk=5  row | | pk=15 row | | pk=25  row     |
    | pk=9  row | +-----------+ | pk=30  row     |
    +-----------+               +----------------+
    <-------------------- 双向链表 -------------------->
所以主键查询最快：
where pk=15 → 找到叶子页 → 直接拿到整行。


# 二级索引(Secondary Index)/普通索引：
数据与索引分开，索引结构的叶子节点关联对应主键
每张表都可以存在多个二级索引，一般由用户创建

                       (Root)
                   [ "Li" | "Wang" ]
                  /       |         \
                 /        |          \
            ["Chen"]   ["Li"]      ["Wang","Zhao"]
      
               |          |             |
               v          v             v
            (Leaf)      (Leaf)        (Leaf)
    +--------------+ +-------------+ +---------------+
    | Chen , pk=7  | | Li , pk=15  | | Wang , pk=10  |  <- 叶子节点：存储(索引列值, 主键值 pk)
    | Chen , pk=20 | | Li , pk=31  | | Zhao , pk=25  |
    +--------------+ +-------------+ +---------------+
    <------------------ 叶子双向链表 ------------------->


# 聚集索引：
# 主键>UNIQUE NOT NULL>自动生成 row_id

# 查找
# 聚集索引的节点按照主键排，叶子节点存放行数据
# 二级索引的节点按照字段排，叶子节点存放主键值
# 回表查询：在二级索引查到主键后，进入到聚集索引中查找行数据
```

### 2. 基本操作
```
# 索引类型
primary         # 主键索引 聚簇索引、一个表只有一个
unique          # 唯一索引 唯一约束+索引
index           # 普通索引
fulltext        # 全文索引 倒排索引 分词做值 效率比like高
spatial         # 空间索引
# 前缀索引
# 联合索引

# 创建索引
create [unique|fulltext] index idx_name on tb_name(col_name1,col_name2,);

# 查看索引
show index from tb_name;

# 删除索引
drop index idx_name on tb_name;

# 修改索引，索引不能修改，只能删除重建
ALTER TABLE tb_name DROP INDEX idx_name, ADD INDEX idx_new(col);

# 前缀索引，选取字符型字段的前n个值作为索引值
CREATE INDEX idx_name ON t(name(10));  -- 前缀索引

# 例子
select database();

select * from t1;

show index from t1;

create index idx_id on t1(id);

create unique index idx_name on t1(name);
```

### 3. 性能分析
```
# 查看当前数据库的命令使用数量
show global/session status like 'com_______';  # 模糊匹配，七个下划线，select,insert,update...
```

### 4. 慢查询
```
# 日志记录所有执行时间超过long_query_time的语句
# 查看慢查询状态
show variables like '%slow_query_log%';

# 开启慢查询
set global slow_query_log = 1;

# 设置慢查询时间, 默认10秒
set global long_query_time = 2;

# 没用索引的 SQL 也记录
SET GLOBAL log_queries_not_using_indexes = 1;
```

### 5. profile
```
# profile:查看每一条sql语句的执行时间
# 查看是否支持profile
select @@have_profiling;

# 查看profile是否开启
select @@profiling;

# 开启profile:
set profiling = 1;

# 查看每一条sql语句的执行情况
show profiles;

# 查看指定query_id的sql语句的各阶段的执行情况
show profile for query query_id;

# 查看指定query_id的sql语句的cpu使用情况
show profile cpu for query query_id;
```

### 6. explain执行计划
```
explain/desc select col_name from tb_name where 条件;

# explain中各个字段的含义：
# id：查询序列号，大的优先，相同时由上往下
# select_type：查询类型
# type：连接类型，null>system>const>eq_ref>ref>range>index>all
# possible_key：可能用到的索引
# key：实际用到的索引
# key_len：索引字节数
# rows：总查询的行数
# filtered：返回结果的行数占读取行数的百分比
# extra: 使用的查询类型:
    use where:存在 Server 层过滤条件，不等于没走索引
    use index:查询的数据全部来自索引，不需要回表
    use filesort:排序无法利用索引，需要在内存中排序
    Using temporary:使用临时表进行中间计算，通常需要优化索引或 SQL 结构。
```

### 7. 联合索引
```
# 最左前缀法则：联合索引的第一个字段必须存在，否则后面的字段索引失效
联合索引 (a,b,c) 能用上的前提是：查询条件从最左列 a 开始，形成连续前缀。
如：
a=...
a=... AND b=...
a=... AND b=... AND c=...
a=... AND b > ...（到 b 为止，c 通常用不上）

# 通过explain的key_len计算各字段的索引长度，以此分辨哪个字段的索引失效

# 索引失效：
# 索引列上进行函数/运算操作
# 范围查询后的索引会失效：>,>=,<,<=,between,like;如果范围查询作为最后一位不会失效
# 字符串不加引号（会触发隐式类型转换）
# 头部模糊匹配，LIKE '%arm'不行，但是LIKE 'arm%'可以
# or其中一个条件无索引，WHERE a=1 OR b=2，b无索引，解决方法：拆成 UNION ALL或补索引
# 使用索引比全表扫描慢：
    选择性差（例如 gender 只有男女）
    要返回数据量太大
    回表成本高
当选择性差或回表代价高时，优化器可能选择全表扫描
```

### 8. sql提示
```
# sql提示优化器使用/忽略哪个索引
# use index： 推荐使用索引，但是优化器可以不听
select * from tb_name use index(idx_name_pro) where profession = '软件工程';

# ignore index:  忽略不同索引
select * from tb_name ignore index(idx_name_pro) where profession = '软件工程';

# force index:  强力推荐使用索引
select * from tb_name force index(idx_name_pro) where profession = '软件工程';
```

### 9. 覆盖索引
```
# id为主键，name为二级索引
# 此时只需要在二级索引中查询就能找到所需的(name,id)，并不需要回表查询name
select id,name from tb_name where name = "arm";

# 如果存在引age不在idx_name
SELECT id, name, age FROM tb_name WHERE name = 'arm';
流程变成：
    用 idx_name 找到 id,name
    回表（用 id 查聚簇索引）  
    拿 age

# 使用联合索引同理
# id为主键，name,pro,ads为联合索引
select id,name,pro,ads from tb_name where name = "arm" and pro = "软件工程" and ads = 0;
```

### 10. 前缀索引
```
# 当需要查询文本文件时，文本太长，就算使用索引也是很耗费时间，因此抽取文本的一部分来建立索引最佳

# 查看有多少条数据
select count(*) from tb_user;

# 查看有多少条不为空的数据
select count(col_name) from tb_user;

# 查看有所少条不同的数据
select count(distinct col_name) from tb_user;

# 表示不同数比上总数
select count(distinct col_name)/count(*) from tb_user;

# 表示截取(1-10)非空字符长度比上总数
select count(distinct substring(col_name,1,10))/count(*) from tb_user;
不断减少截取长度以获取效率，同时精准度也会下降，需要按照具体事务来选择

# 截取长度创立索引
create index idx_col_name_n on tb_name(col_name(length));
length为所截取的前缀长度，主要是对于字符串而言
```
